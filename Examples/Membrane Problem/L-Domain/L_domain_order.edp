border g1(t=-1,0){x=t;y=-1;};
border g2(t=-1,0){x=0;y=t;};
border g3(t=0,1){x=t;y=0;};
border g4(t=0,1){x=1;y=t;};
border g5(t=1,-1){x=t;y=1;};
border g6(t=1,-1){x=-1;y=t;};


int N = 30;
int n = 3,p; // Mesh size for the first loop.

real[int] l2error(n);
real[int] order(n-1);

for(p=0; p<n; p++)
{
	mesh Th = buildmesh(g1(N)+g2(N)+g3(N)+g4(N)+g5(N)+g6(N));

	fespace Vh(Th,P1);

	Vh u,v;
	Vh Ue = sin(pi*x)*cos(pi*y);

	func f = 2*pi^2*sin(pi*x)*cos(pi*y);
	func uexact = sin(pi*x)*cos(pi*y);

	problem Poisson(u,v) = int2d(Th)(dx(u)*dx(v)+dy(u)*dy(v)) - int2d(Th)(f*v) + on(g1,g5,u=-sin(pi*x)) + on(g2,g4,g6,u=0)
							+ on(g3,u=sin(pi*x));

	Poisson;
	
	plot(u, fill=true, wait = false);
	
	l2error[p] = sqrt( int2d(Th)((u-uexact))^2 );
	
	cout<<"L^2 - error = "<<l2error[p]<<" At iteration "<<p+1<<endl;
	N = N*2;
}
for (int i=0; i<n-1; i++)
{
	order[i] = log(l2error[i]/l2error[i+1])/log(2.);
	cout<<"Order of convergence = "<<order[i]<<endl;
}